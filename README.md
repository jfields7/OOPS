# OOPS
We don't like to talk about it, but scientists make terrible software developers. They get away with it because their sloppily written code is usually fast -- everything is procedural, hard-coded, and intended to solve exactly one problem exactly one way. Unfortunately, this makes code maintenance a nightmare. The code is hard to use and impossible to read; modifying it to solve a new problem is often the subject of a PhD dissertation. To be frank, this really stinks, and it would be a lot better to have something more flexible.

Object-oriented programming, on the other hand, is not known for its speed. Abstraction adds overhead, so the code is slower. Writing good OOP code can take a long time, so the development is slower. But sometimes you have a simple problem you need to solve, or perhaps you have a new idea you want to try before implementing it in a bigger, better, faster code. If you put in all that hard work to write a nice object-oriented framework, you can basically just copy and paste your problem into the code and watch it go. If only scientists actually wrote object-oriented code...

Now you have OOPS - the Object-Oriented PDE Solver. It's simple, it's easy, and it reduces solving a new PDE to defining a right-hand side routine and boundary conditions. Things like grid setup and interpolation, ODE solvers, and managing memory are abstracted away so you don't have to worry about them. At the same time, you <i>could</i> worry about them if you wanted to; if the standard RK4 solver isn't enough for you, and what you <i>really</i> need is an adaptive implicit solver for your chemical reactions, you can write that, too, and see it automatically work with everything else.

Is it the fastest kid on the block? Probably not. Will you get your code working faster? Almost certainly.

OOPS also prides itself on being portable. Difficult installation procedures are a personal pet peeve, and the easiest way to ensure that code compiles with just the tap of a button is to eliminate as many external dependencies as possible. While a few optional features may require additional libraries, all core features only require a reasonably modern C++ compiler (C++11 or later), CMake, and Python 3 with standard libraries. This even includes a couple pleasant surprises like parameter file parsers and code generation. In theory, OOPS should be able to run on Windows, MacOS, or your favorite Linux distribution without sacrificing any of the most important features.

# Using OOPS
The best way to get started is to [read the documentation](https://github.com/jfields7/OOPS/wiki) on the wiki (currently a work in progress) and look at the `FieldTest`, `AdaptiveTest`, and `MultiGrid` examples in the repository.
